<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>My Text Editor</title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.8.0/css/bulma.min.css">
  <script defer src="https://use.fontawesome.com/releases/v5.3.1/js/all.js"></script>


</head>

<body>
  <nav>
    <input type="button" onclick="AjoutCube()">
    <form>
      <label>X</label>
      <input id="X" type="text">
      <label>Y</label>
      <input id="Y" type="text">
      <label>Z</label>
      <input id="Z" type="text">
      <label>Nombre</label>
      <input id="nombre" type="text">
      <input type="button" value="Créer l'ensemble" onclick="BoutonCréer()" >
      <input type="button" value="Ranger" onclick="OnEnvoiLeGrosTasDeMerde()" >

    </form>
  </nav>
  <!--
    div class="columns is-mobile">
    <div class="column is-half is-offset-one-quarter">
      <h1 class="title">Calcul tes grands ancêtres</h1>
    </div>
    Combien mesure le contenant ?
    <input id="nbContenant">
  </div>
-->
  <script src="renderer.js"></script>
  <script>


    //var OrbitControls= require('');
    // var THREE=require('three');
    //let OrbitControls= require('three').OrbitControls;

    //console.log(OrbitControls);

    var x = 0;
    var z = 0
    function moveRight() {
      x++;
      camera.position.set(x, 0, z);

    }
    function moveLeft() {
      x--;
      camera.position.set(x, 0, z);

    }
    function moveBack() {
      z--;
      camera.position.set(x, 0, z);
    }

    function moveFront() {
      z++;
      camera.position.set(x, 0, z);
    }

    function animate() {
      requestAnimationFrame(animate);
      //cube.rotation.x += 0.01;
      //cube.rotation.y += 0.01;
      renderer.render(scene, camera);
    }

    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);


    var renderer = new THREE.WebGLRenderer();
    var controls = new  OrbitControls(camera, renderer.domElement);
    controls.enabled=true;
    controls.enableKeys=true;
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    var geometry = new THREE.BoxGeometry(1, 1, 1,1,1,1);
    var material = new THREE.MeshBasicMaterial({ color: 0x4287f5,transparent:true, opacity:0.8 });
    //var cube = new THREE.Mesh(new THREE.BoxGeometry(10, 10, 10,1,1,1), new THREE.MeshBasicMaterial({color: 0xcd62d1,transparent:true, opacity:0.1, wireframe: true}));
    var superCube=new superCube();
    var box= new Boite();
    var box2= new Boite(5,1,1);
    var box3= new Boite(4,1,1)
    
    //superCube.AddBox(box);
    //superCube.AddBox(box2,{x:0,y:0,z:0});
    //superCube.AddBox(box3,{x:3,y:0,z:0});
    superCube.AddAllToScene(scene);

    //new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1,1,1,1),new THREE.MeshBasicMaterial({color: 0xcd62d1,transparent:true, opacity:0.8}));
    //cube2.position.set(0,0,0);
    //var cube3=new THREE.Mesh(geometry,new THREE.MeshBasicMaterial({color: 0xd16276,transparent:true, opacity:0.8}))
    //cube.material.opacity=0.1;
    //scene.add(superCube);
    //scene.add(box);
    //scene.add(cube3);
    //cube2.scale.x=3;
    //cube2.position.setX(cube2.geometry.parameters.width/2+0.5);
    //cube2.position.set(0,0,0);
    //cube3.position.setY(1);
    //console.log(JSON.parse(JSON.stringify(cube2)));
    //console.log(cube2.geometry.parameters.width);
    //console.log(JSON.parse(JSON.stringify(superCube.list[0])));
    //scene.add(cube2);
    /*camera.rotateY(90*Math.PI/180);
    camera.rotateZ(90*Math.PI/180);*/
    camera.position.z = 50;
    controls.update;
    var mesBoitesDeMerde=[];
    
    animate();

    function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
    async function AjoutCube(){
      var box= new Boite(5,5,5);
      superCube.AddBox(box);
      superCube.AddAllToScene(scene);
      animate();
    }

    async function DimensionAleat(maxX, maxY, maxZ){
      var rand= Math.random();
      var hauteur= rand*maxY;
      await sleep(3000);
      var profondeur= rand*maxZ;
      await sleep(3000);
      var largeur= rand*maxX;

      return {x:largeur,y:profondeur,z:hauteur};

      

    }

    function CreationEnsemble(X,Y,Z,nb){
      for(let count=0; count<nb; count++){
        var box= new Boite(X,Y,Z);
        mesBoitesDeMerde.push(box);
      }
    }

    async function OnEnvoiLeGrosTasDeMerde(){
      console.log("appel merde");
      mesBoitesDeMerde.sort((a,b)=>{
       return a.geometry.parameters.width*a.geometry.parameters.height*a.geometry.parameters.depth - b.geometry.parameters.width*b.geometry.parameters.height*b.geometry.parameters.depth;
      });
      for (let count=0;count<mesBoitesDeMerde.length;count++){
        superCube.AddBox(mesBoitesDeMerde[count]);
        superCube.AddAllToScene(scene);
        animate();
        await sleep(3000);
      }
    }

    function BoutonCréer(){
      console.log("appel Bouton");
      let X= parseInt(document.getElementById('X').value);
      let Y= parseInt(document.getElementById('Y').value);
      let Z= parseInt(document.getElementById('Z').value);
      let nb =parseInt(document.getElementById('nombre').value);
      CreationEnsemble(X,Y,Z,nb);
      alert(`ensemble de ${nb} éléments créées de dimension {${X},${Y},${Z}}`);
    }





    /*document.addEventListener("keydown", (e) => {
      switch (e.code) {
        case "ArrowRight":
          //console.log('at the right');
          moveRight();
          break;
        case "ArrowLeft":
          //console.log('at the left');
          moveLeft();
          break;

        case "ArrowUp":
          moveFront();
          break;

        case "ArrowDown":
          moveBack();
          break;

      }
    })*/
  </script>
</body>

</html>